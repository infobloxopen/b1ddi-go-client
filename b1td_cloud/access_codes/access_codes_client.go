// Code generated by go-swagger; DO NOT EDIT.

package access_codes

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new access codes API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for access codes API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	AccessCodesCreateAccessCode(params *AccessCodesCreateAccessCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccessCodesCreateAccessCodeCreated, error)

	AccessCodesDeleteAccessCodes(params *AccessCodesDeleteAccessCodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccessCodesDeleteAccessCodesNoContent, error)

	AccessCodesDeleteSingleAccessCodes(params *AccessCodesDeleteSingleAccessCodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccessCodesDeleteSingleAccessCodesNoContent, error)

	AccessCodesListAccessCodes(params *AccessCodesListAccessCodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccessCodesListAccessCodesOK, error)

	AccessCodesReadAccessCode(params *AccessCodesReadAccessCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccessCodesReadAccessCodeOK, error)

	AccessCodesUpdateAccessCode(params *AccessCodesUpdateAccessCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccessCodesUpdateAccessCodeCreated, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
	AccessCodesCreateAccessCode creates access codes

	Use this method to create the Bypass Code corresponding to the

security rules passed.
It's an atomic operation. It should create all the security rules
and create the policy and bypass codes, or do nothing if any of them fails.

Required:
- name
- rules
- activation
- expiration
*/
func (a *Client) AccessCodesCreateAccessCode(params *AccessCodesCreateAccessCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccessCodesCreateAccessCodeCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAccessCodesCreateAccessCodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "access_codesCreateAccessCode",
		Method:             "POST",
		PathPattern:        "/access_codes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AccessCodesCreateAccessCodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AccessCodesCreateAccessCodeCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for access_codesCreateAccessCode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	AccessCodesDeleteAccessCodes deletes access codes

	Use this method to delete Bypass Code objects. Deletion of

multiple bypass codes is an all-or-nothing operation (if any of
the specified bypass codes cannot be deleted then none of the
specified bypass codes will be deleted).

Required:
- ids
*/
func (a *Client) AccessCodesDeleteAccessCodes(params *AccessCodesDeleteAccessCodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccessCodesDeleteAccessCodesNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAccessCodesDeleteAccessCodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "access_codesDeleteAccessCodes",
		Method:             "DELETE",
		PathPattern:        "/access_codes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AccessCodesDeleteAccessCodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AccessCodesDeleteAccessCodesNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for access_codesDeleteAccessCodes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AccessCodesDeleteSingleAccessCodes deletes access code by ID

Use this method to delete Bypass Code object.
*/
func (a *Client) AccessCodesDeleteSingleAccessCodes(params *AccessCodesDeleteSingleAccessCodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccessCodesDeleteSingleAccessCodesNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAccessCodesDeleteSingleAccessCodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "access_codesDeleteSingleAccessCodes",
		Method:             "DELETE",
		PathPattern:        "/access_codes/{access_key}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AccessCodesDeleteSingleAccessCodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AccessCodesDeleteSingleAccessCodesNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for access_codesDeleteSingleAccessCodes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AccessCodesListAccessCodes lists access codes

Use this method to retrieve a collection of Bypass Code objects.
*/
func (a *Client) AccessCodesListAccessCodes(params *AccessCodesListAccessCodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccessCodesListAccessCodesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAccessCodesListAccessCodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "access_codesListAccessCodes",
		Method:             "GET",
		PathPattern:        "/access_codes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AccessCodesListAccessCodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AccessCodesListAccessCodesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for access_codesListAccessCodes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AccessCodesReadAccessCode reads access codes

Use this method to retrieve the Bypass Code by key.
*/
func (a *Client) AccessCodesReadAccessCode(params *AccessCodesReadAccessCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccessCodesReadAccessCodeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAccessCodesReadAccessCodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "access_codesReadAccessCode",
		Method:             "GET",
		PathPattern:        "/access_codes/{access_key}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AccessCodesReadAccessCodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AccessCodesReadAccessCodeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for access_codesReadAccessCode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	AccessCodesUpdateAccessCode updates access codes

	Use this method to update the Bypass Code corresponding to the security rules passed.

It's an atomic operation. It should delete existing security rules and
create all the new security rules for the bypass code,
or do nothing if any of them fails.

Required:
- name
- rules
- dfps
- network_lists
- roaming_device_groups
*/
func (a *Client) AccessCodesUpdateAccessCode(params *AccessCodesUpdateAccessCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AccessCodesUpdateAccessCodeCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAccessCodesUpdateAccessCodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "access_codesUpdateAccessCode",
		Method:             "PUT",
		PathPattern:        "/access_codes/{payload.access_key}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AccessCodesUpdateAccessCodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AccessCodesUpdateAccessCodeCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for access_codesUpdateAccessCode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
