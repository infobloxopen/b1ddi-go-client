// Code generated by go-swagger; DO NOT EDIT.

package network_lists

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new network lists API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for network lists API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	NetworkListsCreateNetworkList(params *NetworkListsCreateNetworkListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NetworkListsCreateNetworkListCreated, error)

	NetworkListsDeleteNetworkLists(params *NetworkListsDeleteNetworkListsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NetworkListsDeleteNetworkListsNoContent, error)

	NetworkListsDeleteSingleNetworkLists(params *NetworkListsDeleteSingleNetworkListsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NetworkListsDeleteSingleNetworkListsNoContent, error)

	NetworkListsListNetworkLists(params *NetworkListsListNetworkListsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NetworkListsListNetworkListsOK, error)

	NetworkListsReadNetworkList(params *NetworkListsReadNetworkListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NetworkListsReadNetworkListOK, error)

	NetworkListsUpdateNetworkList(params *NetworkListsUpdateNetworkListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NetworkListsUpdateNetworkListCreated, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
	NetworkListsCreateNetworkList creates network list

	Use this method to create a Network List object.

Before you can apply security policies, you must first define the networks that you want to protect from malicious attacks. The first step in configuring BloxOne Cloud is to set up DNS Firewall by defining your remote networks. You identify these external networks by their IP addresses. A network can contain a group of IPv4 or IPv6 addresses or blocks.

Required:
- name
- items
*/
func (a *Client) NetworkListsCreateNetworkList(params *NetworkListsCreateNetworkListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NetworkListsCreateNetworkListCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNetworkListsCreateNetworkListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "network_listsCreateNetworkList",
		Method:             "POST",
		PathPattern:        "/network_lists",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NetworkListsCreateNetworkListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NetworkListsCreateNetworkListCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for network_listsCreateNetworkList: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	NetworkListsDeleteNetworkLists deletes network lists

	Use this method to delete the Network List objects. Deletion of multiple lists is an all-or-nothing operation (if any of the specified lists can not be deleted then none of the specified lists will be deleted).

Before you can apply security policies, you must first define the networks that you want to protect from malicious attacks. The first step in configuring BloxOne Cloud is to set up DNS Firewall by defining your remote networks. You identify these external networks by their IP addresses. A network can contain a group of  or IPv6 addresses or blocks.

Required:
- ids
*/
func (a *Client) NetworkListsDeleteNetworkLists(params *NetworkListsDeleteNetworkListsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NetworkListsDeleteNetworkListsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNetworkListsDeleteNetworkListsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "network_listsDeleteNetworkLists",
		Method:             "DELETE",
		PathPattern:        "/network_lists",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NetworkListsDeleteNetworkListsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NetworkListsDeleteNetworkListsNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for network_listsDeleteNetworkLists: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	NetworkListsDeleteSingleNetworkLists deletes network lists

	Use this method to delete the Network List object by the specified Network List object id.

Before you can apply security policies, you must first define the networks that you want to protect from malicious attacks. The first step in configuring BloxOne Cloud is to set up DNS Firewall by defining your remote networks. You identify these external networks by their IP addresses. A network can contain a group of  or IPv6 addresses or blocks.
*/
func (a *Client) NetworkListsDeleteSingleNetworkLists(params *NetworkListsDeleteSingleNetworkListsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NetworkListsDeleteSingleNetworkListsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNetworkListsDeleteSingleNetworkListsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "network_listsDeleteSingleNetworkLists",
		Method:             "DELETE",
		PathPattern:        "/network_lists/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NetworkListsDeleteSingleNetworkListsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NetworkListsDeleteSingleNetworkListsNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for network_listsDeleteSingleNetworkLists: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	NetworkListsListNetworkLists lists network lists

	Use this method to retrieve information on all Network List objects for the account.

Before you can apply security policies, you must first define the networks that you want to protect from malicious attacks. The first step in configuring BloxOne Cloud is to set up DNS Firewall by defining your remote networks. You identify these external networks by their IP addresses. A network can contain a group of IPv4 or IPv6 addresses or blocks.
*/
func (a *Client) NetworkListsListNetworkLists(params *NetworkListsListNetworkListsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NetworkListsListNetworkListsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNetworkListsListNetworkListsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "network_listsListNetworkLists",
		Method:             "GET",
		PathPattern:        "/network_lists",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NetworkListsListNetworkListsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NetworkListsListNetworkListsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for network_listsListNetworkLists: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	NetworkListsReadNetworkList reads network list

	Use this method to retrieve information on the specified Network List object.

Before you can apply security policies, you must first define the networks that you want to protect from malicious attacks. The first step in configuring BloxOne Cloud is to set up DNS Firewall by defining your remote networks. You identify these external networks by their IP addresses. A network can contain a group of IPv4 or IPv6 addresses or blocks.
*/
func (a *Client) NetworkListsReadNetworkList(params *NetworkListsReadNetworkListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NetworkListsReadNetworkListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNetworkListsReadNetworkListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "network_listsReadNetworkList",
		Method:             "GET",
		PathPattern:        "/network_lists/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NetworkListsReadNetworkListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NetworkListsReadNetworkListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for network_listsReadNetworkList: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	NetworkListsUpdateNetworkList updates network list

	Use this method to update a specified Network List object.

Before you can apply security policies, you must first define the networks that you want to protect from malicious attacks. The first step in configuring BloxOne Cloud is to set up DNS Firewall by defining your remote networks. You identify these external networks by their IP addresses. A network can contain a group of IPv4 or IPv6 addresses or blocks.

Required:
- name
- items
*/
func (a *Client) NetworkListsUpdateNetworkList(params *NetworkListsUpdateNetworkListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NetworkListsUpdateNetworkListCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNetworkListsUpdateNetworkListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "network_listsUpdateNetworkList",
		Method:             "PUT",
		PathPattern:        "/network_lists/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NetworkListsUpdateNetworkListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NetworkListsUpdateNetworkListCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for network_listsUpdateNetworkList: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
