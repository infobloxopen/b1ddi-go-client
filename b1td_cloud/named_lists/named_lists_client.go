// Code generated by go-swagger; DO NOT EDIT.

package named_lists

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new named lists API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for named lists API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	NamedListsCreateNamedList(params *NamedListsCreateNamedListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsCreateNamedListCreated, error)

	NamedListsDeleteNamedLists(params *NamedListsDeleteNamedListsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsDeleteNamedListsNoContent, error)

	NamedListsDeleteSingleNamedLists(params *NamedListsDeleteSingleNamedListsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsDeleteSingleNamedListsNoContent, error)

	NamedListsListNamedLists(params *NamedListsListNamedListsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsListNamedListsOK, error)

	NamedListsListNamedListsCSV(params *NamedListsListNamedListsCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsListNamedListsCSVOK, error)

	NamedListsMultiListUpdate(params *NamedListsMultiListUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsMultiListUpdateCreated, error)

	NamedListsReadNamedList(params *NamedListsReadNamedListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsReadNamedListOK, error)

	NamedListsUpdateNamedList(params *NamedListsUpdateNamedListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsUpdateNamedListCreated, error)

	NamedListsUpdateNamedListPartial(params *NamedListsUpdateNamedListPartialParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsUpdateNamedListPartialCreated, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
	NamedListsCreateNamedList creates named list

	Use this method to create a Named List object.

The Named List object represents several types of lists allowed for BloxOne Cloud such as predefined threat intelligence feeds that your subscription offers (Threat Insight, Fast Flux, DGA, DNSM). In addition to the predefined threat intelligence feeds that your subscription offers, you can create custom lists (containing domains and IP addresses) to define whitelists and blacklists for additional protection. You can use a custom list to complement existing feeds or override the Block, Allow, Log, or Redirect action that is currently defined for an existing feed. Note that lists representing predefined TI feeds cannot be created, updated and deleted. Also use of the field 'items' is discouraged and instead use of new field 'item_described' is suggested as it is possible to add the description/comments to each item in the custom list using this field. In any case, note that use of both the fields 'items' and 'items_described' is not supported and when one of these field is used they must have some value i.e, it cannot be empty.

Required:
- name
- type
- items or items_described
*/
func (a *Client) NamedListsCreateNamedList(params *NamedListsCreateNamedListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsCreateNamedListCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNamedListsCreateNamedListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "named_listsCreateNamedList",
		Method:             "POST",
		PathPattern:        "/named_lists",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NamedListsCreateNamedListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NamedListsCreateNamedListCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for named_listsCreateNamedList: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	NamedListsDeleteNamedLists deletes named lists

	Use this method to delete Named List objects. Deletion of multiple lists is an all-or-nothing operation (if any of the specified lists can not be deleted then none of the specified lists will be deleted).

The Named List object represents several types of lists allowed for BloxOne Cloud such as predefined threat intelligence feeds that your subscription offers (Threat Insight, Fast Flux, DGA, DNSM). In addition to the predefined threat intelligence feeds that your subscription offers, you can create custom lists (containing domains and IP addresses) to define whitelists and blacklists for additional protection. You can use a custom list to complement existing feeds or override the Block, Allow, Log, or Redirect action that is currently defined for an existing feed. Note that lists representing predefined TI feeds cannot be created, updated and deleted.

Required:
- ids
*/
func (a *Client) NamedListsDeleteNamedLists(params *NamedListsDeleteNamedListsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsDeleteNamedListsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNamedListsDeleteNamedListsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "named_listsDeleteNamedLists",
		Method:             "DELETE",
		PathPattern:        "/named_lists",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NamedListsDeleteNamedListsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NamedListsDeleteNamedListsNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for named_listsDeleteNamedLists: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	NamedListsDeleteSingleNamedLists deletes named lists

	Use this method to delete Named List object by given Named List object identifier.

The Named List object represents several types of lists allowed for BloxOne Cloud such as predefined threat intelligence feeds that your subscription offers (Threat Insight, Fast Flux, DGA, DNSM). In addition to the predefined threat intelligence feeds that your subscription offers, you can create custom lists (containing domains and IP addresses) to define whitelists and blacklists for additional protection. You can use a custom list to complement existing feeds or override the Block, Allow, Log, or Redirect action that is currently defined for an existing feed. Note that lists representing predefined TI feeds cannot be created, updated and deleted.
*/
func (a *Client) NamedListsDeleteSingleNamedLists(params *NamedListsDeleteSingleNamedListsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsDeleteSingleNamedListsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNamedListsDeleteSingleNamedListsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "named_listsDeleteSingleNamedLists",
		Method:             "DELETE",
		PathPattern:        "/named_lists/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NamedListsDeleteSingleNamedListsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NamedListsDeleteSingleNamedListsNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for named_listsDeleteSingleNamedLists: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	NamedListsListNamedLists lists named lists

	Use this method to retrieve information on all Named List objects for the account. Note that list items are not returned for this operation.

The Named List object represents several types of lists allowed for BloxOne Cloud such as predefined threat intelligence feeds that your subscription offers (Threat Insight, Fast Flux, DGA, DNSM). In addition to the predefined threat intelligence feeds that your subscription offers, you can create custom lists (containing domains and IP addresses) to define whitelists and blacklists for additional protection. You can use a custom list to complement existing feeds or override the Block, Allow, Log, or Redirect action that is currently defined for an existing feed. Note that lists representing predefined TI feeds cannot be created, updated and deleted.
*/
func (a *Client) NamedListsListNamedLists(params *NamedListsListNamedListsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsListNamedListsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNamedListsListNamedListsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "named_listsListNamedLists",
		Method:             "GET",
		PathPattern:        "/named_lists",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NamedListsListNamedListsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NamedListsListNamedListsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for named_listsListNamedLists: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
NamedListsListNamedListsCSV lists named lists in c s v format

Use this method to download the selected list of named lists in CSV (comma-separate values) format.
*/
func (a *Client) NamedListsListNamedListsCSV(params *NamedListsListNamedListsCSVParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsListNamedListsCSVOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNamedListsListNamedListsCSVParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "named_listsListNamedListsCSV",
		Method:             "GET",
		PathPattern:        "/named_lists_download",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NamedListsListNamedListsCSVReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NamedListsListNamedListsCSVOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for named_listsListNamedListsCSV: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	NamedListsMultiListUpdate patches multiple named lists

	Multiple Named Lists in a single operation.

Use this method to insert items for multiple Named List objects. Note that duplicated items correspondig to named list are silently skipped and only new items are appended to the named list. Note that DNSM, TI, Fast Flux and DGA lists cannot be updated. Only named lists of Custom List type can be updated by this operation.
If one or more of the list ids is invalid, or the list is of invalid type then the entire operation will be failed.
The Custom List Items represent the list of the FQDN or IPv4 addresses to define whitelists and blacklists for additional protection.
*/
func (a *Client) NamedListsMultiListUpdate(params *NamedListsMultiListUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsMultiListUpdateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNamedListsMultiListUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "named_listsMultiListUpdate",
		Method:             "PATCH",
		PathPattern:        "/named_lists",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NamedListsMultiListUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NamedListsMultiListUpdateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for named_listsMultiListUpdate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	NamedListsReadNamedList reads named list

	Use this method to retrieve information on the specified Named List object. Note that returned data includes list items.

The Named List object represents several types of lists allowed for BloxOne Cloud such as predefined threat intelligence feeds that your subscription offers (Threat Insight, Fast Flux, DGA, DNSM). In addition to the predefined threat intelligence feeds that your subscription offers, you can create custom lists (containing domains and IP addresses) to define whitelists and blacklists for additional protection. You can use a custom list to complement existing feeds or override the Block, Allow, Log, or Redirect action that is currently defined for an existing feed. Note that lists representing predefined TI feeds cannot be created, updated and deleted.
*/
func (a *Client) NamedListsReadNamedList(params *NamedListsReadNamedListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsReadNamedListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNamedListsReadNamedListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "named_listsReadNamedList",
		Method:             "GET",
		PathPattern:        "/named_lists/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NamedListsReadNamedListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NamedListsReadNamedListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for named_listsReadNamedList: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	NamedListsUpdateNamedList updates named list

	Use this method to update the specified Named List object. Note that list type cannot be updated.

The Named List object represents several types of lists allowed for BloxOne Cloud such as predefined threat intelligence feeds that your subscription offers (Threat Insight, Fast Flux, DGA, DNSM). In addition to the predefined threat intelligence feeds that your subscription offers, you can create custom lists (containing domains and IP addresses) to define whitelists and blacklists for additional protection. You can use a custom list to complement existing feeds or override the Block, Allow, Log, or Redirect action that is currently defined for an existing feed. Note that lists representing predefined TI feeds cannot be created, updated and deleted. Also use of the field 'items' is discouraged and instead use of new field 'item_described' is suggested as it is possible to add the description/comments to each item in the custom list using this field. In any case, note that use of both the fields 'items' and 'items_described' is not supported and when one of these field is used they must have some value i.e, it cannot be empty.

Required:
- name
- items or items_described
*/
func (a *Client) NamedListsUpdateNamedList(params *NamedListsUpdateNamedListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsUpdateNamedListCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNamedListsUpdateNamedListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "named_listsUpdateNamedList",
		Method:             "PUT",
		PathPattern:        "/named_lists/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NamedListsUpdateNamedListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NamedListsUpdateNamedListCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for named_listsUpdateNamedList: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	NamedListsUpdateNamedListPartial patches t i list

	Use this method to update the Severity for a specified named list, which must be of TI list type.

The severity levels (threat_level and confidence_level) can only be patched for a given id of a TI List.
This patch request only accepts threat_level and confidence level as the attributes. At least one of these two attributes must be present in the request. If only one of the two attributes is present, only that attribute is set to the specified value for the specified list and other attribute will be at the present value.
This operation is currently applicable only for the TI Lists.

Required:
- id
- threat_level or confidence_level
*/
func (a *Client) NamedListsUpdateNamedListPartial(params *NamedListsUpdateNamedListPartialParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NamedListsUpdateNamedListPartialCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNamedListsUpdateNamedListPartialParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "named_listsUpdateNamedListPartial",
		Method:             "PATCH",
		PathPattern:        "/named_lists/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NamedListsUpdateNamedListPartialReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NamedListsUpdateNamedListPartialCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for named_listsUpdateNamedListPartial: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
