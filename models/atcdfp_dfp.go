// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AtcdfpDfp atcdfp dfp
//
// swagger:model atcdfpDfp
type AtcdfpDfp struct {

	// The time when this DNS Forwarding Proxy object was created.
	// Read Only: true
	// Format: date-time
	CreatedTime strfmt.DateTime `json:"created_time,omitempty"`

	// The list of default DNS resolvers that will be used in case if the BloxOne Cloud is unreachable.  Deprecated DO NOT USE. Use resolvers_all.
	// Example: ["4.4.4.4","2001:cdba:9abc:5678:ffff:ffff:ffff:ffff"]
	// Read Only: true
	DefaultResolvers []string `json:"default_resolvers"`

	// The list of internal or local DNS servers' IPv4 or IPv6 addresses that are used as ELB IPs.
	// Example: ["1.1.1.1","2001:cdba:9abc:5678:ffff:ffff:ffff:ffff"]
	// Read Only: true
	ElbIPList []string `json:"elb_ip_list"`

	// host information. For internal Use only.
	Host []*AtcdfpDfpHost `json:"host"`

	// The DNS Forwarding Proxy object identifier.
	// Read Only: true
	ID int32 `json:"id,omitempty"`

	// The list of internal domains list IDs that are associated with this DFP
	InternalDomainLists []int32 `json:"internal_domain_lists"`

	// The name of the DNS Forwarding Proxy.
	// Example: dfp_a
	// Read Only: true
	Name string `json:"name,omitempty"`

	// List of network-address-scoped security policy assignments
	NetAddrPolicyIds []*AtcdfpNetAddrPolicyAssignment `json:"net_addr_policy_ids"`

	// The On-Prem Host identifier.
	// Example: aed8263b8900bfb178e0bb7c57ba5af8
	// Read Only: true
	Ophid string `json:"ophid,omitempty"`

	// The identifier of the security policy with which the DNS Forwarding Proxy is associated.
	// Example: 52134
	// Read Only: true
	PolicyID int32 `json:"policy_id,omitempty"`

	// Point of Presence (PoP) region
	// Read Only: true
	PopRegionID int32 `json:"pop_region_id,omitempty"`

	// The list of internal or local DNS servers' IPv4 or IPv6 addresses that are used as DNS resolvers. Deprecated DO NOT USE. Use resolvers_all.
	// Example: ["1.1.1.1","2001:cdba:9abc:5678:ffff:ffff:ffff:ffff"]
	// Read Only: true
	Resolvers []string `json:"resolvers"`

	// resolvers all
	ResolversAll []*AtcdfpResolver `json:"resolvers_all"`

	// The On-Prem Application Service identifier. For internal Use only
	// Example: u2y3w3fuhhtx7aykfkuergkuboc33wyqrrmjnr5tyrlyredwow374gu5uwzqnsb6
	// Read Only: true
	ServiceID string `json:"service_id,omitempty"`

	// The On-Prem Application Service name. For internal Use only
	// Example: dfp_service_1
	// Read Only: true
	ServiceName string `json:"service_name,omitempty"`

	// The DNS Forwarding Proxy site identifier that is appended to DNS queries originating from this DNS Forwarding Proxy and subsequently used for policy lookup purposes.
	// Example: 134997289555407a8527bea7957ea7a0
	// Read Only: true
	SiteID string `json:"site_id,omitempty"`

	// The time when this DNS Forwarding Proxy object was last updated.
	// Read Only: true
	// Format: date-time
	UpdatedTime strfmt.DateTime `json:"updated_time,omitempty"`
}

// Validate validates this atcdfp dfp
func (m *AtcdfpDfp) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreatedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHost(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetAddrPolicyIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResolversAll(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AtcdfpDfp) validateCreatedTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("created_time", "body", "date-time", m.CreatedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *AtcdfpDfp) validateHost(formats strfmt.Registry) error {
	if swag.IsZero(m.Host) { // not required
		return nil
	}

	for i := 0; i < len(m.Host); i++ {
		if swag.IsZero(m.Host[i]) { // not required
			continue
		}

		if m.Host[i] != nil {
			if err := m.Host[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("host" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("host" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AtcdfpDfp) validateNetAddrPolicyIds(formats strfmt.Registry) error {
	if swag.IsZero(m.NetAddrPolicyIds) { // not required
		return nil
	}

	for i := 0; i < len(m.NetAddrPolicyIds); i++ {
		if swag.IsZero(m.NetAddrPolicyIds[i]) { // not required
			continue
		}

		if m.NetAddrPolicyIds[i] != nil {
			if err := m.NetAddrPolicyIds[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("net_addr_policy_ids" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("net_addr_policy_ids" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AtcdfpDfp) validateResolversAll(formats strfmt.Registry) error {
	if swag.IsZero(m.ResolversAll) { // not required
		return nil
	}

	for i := 0; i < len(m.ResolversAll); i++ {
		if swag.IsZero(m.ResolversAll[i]) { // not required
			continue
		}

		if m.ResolversAll[i] != nil {
			if err := m.ResolversAll[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resolvers_all" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resolvers_all" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AtcdfpDfp) validateUpdatedTime(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("updated_time", "body", "date-time", m.UpdatedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this atcdfp dfp based on the context it is used
func (m *AtcdfpDfp) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCreatedTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDefaultResolvers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateElbIPList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHost(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetAddrPolicyIds(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOphid(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePolicyID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePopRegionID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResolvers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResolversAll(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServiceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServiceName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSiteID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdatedTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AtcdfpDfp) contextValidateCreatedTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "created_time", "body", strfmt.DateTime(m.CreatedTime)); err != nil {
		return err
	}

	return nil
}

func (m *AtcdfpDfp) contextValidateDefaultResolvers(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "default_resolvers", "body", []string(m.DefaultResolvers)); err != nil {
		return err
	}

	return nil
}

func (m *AtcdfpDfp) contextValidateElbIPList(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "elb_ip_list", "body", []string(m.ElbIPList)); err != nil {
		return err
	}

	return nil
}

func (m *AtcdfpDfp) contextValidateHost(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Host); i++ {

		if m.Host[i] != nil {

			if swag.IsZero(m.Host[i]) { // not required
				return nil
			}

			if err := m.Host[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("host" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("host" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AtcdfpDfp) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", int32(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *AtcdfpDfp) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *AtcdfpDfp) contextValidateNetAddrPolicyIds(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetAddrPolicyIds); i++ {

		if m.NetAddrPolicyIds[i] != nil {

			if swag.IsZero(m.NetAddrPolicyIds[i]) { // not required
				return nil
			}

			if err := m.NetAddrPolicyIds[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("net_addr_policy_ids" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("net_addr_policy_ids" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AtcdfpDfp) contextValidateOphid(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "ophid", "body", string(m.Ophid)); err != nil {
		return err
	}

	return nil
}

func (m *AtcdfpDfp) contextValidatePolicyID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "policy_id", "body", int32(m.PolicyID)); err != nil {
		return err
	}

	return nil
}

func (m *AtcdfpDfp) contextValidatePopRegionID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "pop_region_id", "body", int32(m.PopRegionID)); err != nil {
		return err
	}

	return nil
}

func (m *AtcdfpDfp) contextValidateResolvers(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "resolvers", "body", []string(m.Resolvers)); err != nil {
		return err
	}

	return nil
}

func (m *AtcdfpDfp) contextValidateResolversAll(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ResolversAll); i++ {

		if m.ResolversAll[i] != nil {

			if swag.IsZero(m.ResolversAll[i]) { // not required
				return nil
			}

			if err := m.ResolversAll[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resolvers_all" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resolvers_all" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AtcdfpDfp) contextValidateServiceID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_id", "body", string(m.ServiceID)); err != nil {
		return err
	}

	return nil
}

func (m *AtcdfpDfp) contextValidateServiceName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "service_name", "body", string(m.ServiceName)); err != nil {
		return err
	}

	return nil
}

func (m *AtcdfpDfp) contextValidateSiteID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "site_id", "body", string(m.SiteID)); err != nil {
		return err
	}

	return nil
}

func (m *AtcdfpDfp) contextValidateUpdatedTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "updated_time", "body", strfmt.DateTime(m.UpdatedTime)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AtcdfpDfp) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AtcdfpDfp) UnmarshalBinary(b []byte) error {
	var res AtcdfpDfp
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
