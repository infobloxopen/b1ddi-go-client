// Code generated by go-swagger; DO NOT EDIT.

package dfp

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new dfp API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for dfp API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	DfpCreateOrUpdateDfp(params *DfpCreateOrUpdateDfpParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DfpCreateOrUpdateDfpCreated, error)

	DfpListDfp(params *DfpListDfpParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DfpListDfpOK, error)

	DfpReadDfp(params *DfpReadDfpParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DfpReadDfpOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
	DfpCreateOrUpdateDfp updates DNS forwarding proxy resolvers

	Use this method to update resolvers for the specified DNS Forwarding Proxy.

For remote office deployments or in cases where installing an endpoint agent is not desirable or possible, you can use the DNS forwarding proxy. It is a software that runs on bare-metal, VM infrastructures, or Infoblox NIOS appliances; and it embeds the client IPs in DNS queries before forwarding them to BloxOne Cloud. The communications are encrypted and client visibility is maintained. The proxy also provides DNS resolution to local DNS zones when you configure local resolvers. Once you set up a DNS forwarding proxy, it becomes the main DNS server for your remote site. It will also cache responses to speed resolution of future queries. There is a possibility to set default resolver(s) depending on the license class. DNS forwarding proxy would fallback to the default resolvers when BloxOne Cloud is unreachable.
*/
func (a *Client) DfpCreateOrUpdateDfp(params *DfpCreateOrUpdateDfpParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DfpCreateOrUpdateDfpCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDfpCreateOrUpdateDfpParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "dfpCreateOrUpdateDfp",
		Method:             "PUT",
		PathPattern:        "/dfps/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DfpCreateOrUpdateDfpReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DfpCreateOrUpdateDfpCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for dfpCreateOrUpdateDfp: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	DfpListDfp lists DNS forwarding proxies

	Use this method to retrieve information on all DNS Forwarding Proxy objects for the account.

For remote office deployments or in cases where installing an endpoint agent is not desirable or possible, you can use the DNS forwarding proxy. It is a software that runs on bare-metal, VM infrastructures, or Infoblox NIOS appliances; and it embeds the client IPs in DNS queries before forwarding them to BloxOne Cloud. The communications are encrypted and client visibility is maintained. The proxy also provides DNS resolution to local DNS zones when you configure local resolvers. Once you set up a DNS forwarding proxy, it becomes the main DNS server for your remote site. It will also cache responses to speed resolution of future queries.
*/
func (a *Client) DfpListDfp(params *DfpListDfpParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DfpListDfpOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDfpListDfpParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "dfpListDfp",
		Method:             "GET",
		PathPattern:        "/dfps",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DfpListDfpReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DfpListDfpOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for dfpListDfp: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	DfpReadDfp reads DNS forwarding proxy

	Use this method to retrieve information on the specified DNS Forwarding Proxy object.

For remote office deployments or in cases where installing an endpoint agent is not desirable or possible, you can use the DNS forwarding proxy. It is a software that runs on bare-metal, VM infrastructures, or Infoblox NIOS appliances; and it embeds the client IPs in DNS queries before forwarding them to BloxOne Cloud. The communications are encrypted and client visibility is maintained. The proxy also provides DNS resolution to local DNS zones when you configure local resolvers. Once you set up a DNS forwarding proxy, it becomes the main DNS server for your remote site. It will also cache responses to speed resolution of future queries.

Note that DNS Forwarding Proxy cannot be created (all information regarding DFP is synchronized from hostapp service).
*/
func (a *Client) DfpReadDfp(params *DfpReadDfpParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DfpReadDfpOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDfpReadDfpParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "dfpReadDfp",
		Method:             "GET",
		PathPattern:        "/dfps/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DfpReadDfpReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DfpReadDfpOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for dfpReadDfp: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
